---
title: "Tutorial 4"
---

Virtual environments and docker containers.
We'll practice creating virtual environments again (just like last tutorial),
so we can compare it with creating docker containers.

## R Environments

1. Create a new RStudio Project
2. Note the currently installed packages
3. Install the `renv` library if you do not have it installed
4. Initialize the current project as an `renv` project
5. Note the new packages in the environment.
6. Install an R package
7. Snapsnot the package
8. Note how the `renv.lock` file does not change
9. Create and save an R script that uses the package you just installed
10. Re-snapshot the project
11. Note how the `renv.lock` file updates now
12. Close the current RStudio project
13. Note how you have your old packages back
14. Re-open the RStudio project you just created and see how t5he packages change.

## Python environment

When using Python, `conda` environments have a slightly different workflow when compared to renv.

1. Check that you are currently in the `base` conda environment:

```bash
conda info
```

2. Note the packages in the current conda environment and their versions

```bash
conda list
```

3. Create a new conda environment (we are going to name it `myenv`) with python 3.12

```bash
conda create -n myenv -c conda-forge python=3.12
```

4. Activate this environment
5. Run python and compare your python versions and see if you are able to import `pandas`
6. `conda` install another package into the environment, `pandas` and import it from the new environment.


## Run a docker container

Let's get some practice with running docker containers

Docker Desktop needs to be running in the background.

### Your first container

We did this in the Computer Setup process, but let's run the `hello-world` container with `docker run`

```bash
$ docker run hello-world

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/

$
```

This command runs a container that executes a script that prints out the hello docker text.
When this script runs, it exits and the container exits to give you your prompt back

### An R Container

1. Compare the version of R you have right now on your computer.
You can open up and launch `R` or run `R --version` to get your current R version.
2. Run the R 4.3.2 container:

```bash
docker run --rm -it rocker/r-ver:4.3.2
```

3. Compare the version from the version you have on your computer
4. Try to load a package you have installed on your computer in the container (it should fail)
5. Exit out of this docker container

### A Python Container

1. Compare the version of Python you have right now on your computer.
You can run `python --version` to get your current Python version.
2. Run the latest python:

```bash
docker run --rm -it python
```

3. Compare the version from the version you have on your computer, once the container starts, Python should display its version above the prompt. 
4. Try to load a package you have installed on your computer in the container (it should fail)
5. Exit out of this docker container
6. Run the Python container with the tag "3.12"

```bash
docker run --rm -it python:3.12
```

7. Check the version of Python this prompt shows, and then exit the container. 
7. What comes after the `:` appended to the image name is a user-chosen tag that has no *direct* connection to the contents of the Docker image. But it should provide a semantically meaningful addition to the name. In this instance, why did the developers choose to tag this version of the `python` docker image with the text `3.12`?